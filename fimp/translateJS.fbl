var string jsg, boolean translateJS, outputTypesToJS;
var Function(string, Xob) translateXob;

void function resetJS() {
	jsg = '';
}

void function storeJS(string fln) {
	writeToFile(fln,jsg);
}

string function translateSort(Sort s) {
	if (s == string) return 'string';
	return '';
}

string function translateConstant(Xob xconstant) {
    var string js;
	js = '';
	if (obkind(xconstant) == hashtable_kind) {
		// if (bitsel(xconstant~ob,Xob1_booles,Xob1_isNoop)~boolean) js = ''; // noop => do not translate
		// else js * 'hashtableconstant';
	} else {
		js * xconstant;
	}
    return js;
}

string function translateFunction(Function xfunction) {
	var string js,id nm,Sort tp,SeqOfType itps,Sort rtp,int ln,lnm1,i;
	nm = obsel(xfunction~ob,Function_name)~id;
	tp = obsel(xfunction~ob,Function_type)~Sort;
	rtp = resultType(tp);
	itps = inputTypes(tp);
	js = '';

	js * 'function ';
	if (outputTypesToJS) {
		js * '/*';
		js * rtp;
		js * '*/ ';
	}
	js * nm; // TODO: decorate function name
	js * '(';
	ln = length(itps);
	lnm1 = ln-1;
	for (i = 0;i<ln;i++) {
		js * itps[i];
		if (i < lnm1) js * ',';
	}
	js * ')';
	return js;
}

string function translateBinding(Binding binding) {
    var string js, ob ky, Sort tp0, ob rg;
	js = '';
	ky = obsel(binding~ob,Binding_key);
	if (obkind(ky)==string_kind) js * (ky~id);
	else {
		tp0 = type0(ky);
		if (tp0 == Regarding) {
			rg = obsel(ky,Regarding_value);
			if (obkind(rg) == string_kind) js * rg~id;
			else js * '<unprintable>';
		}
	}
    return js;
}

string function translateAssign(Xassign xassign) {
    var string js;
	js = '';
    js * translateXob(obsel(xassign~ob, Xassign_dest)~Xob);
    js * '=';
    js * translateXob(obsel(xassign~ob, Xassign_source)~Xob);
	js * ';';
    return js;
}

string function translateBlock(Xblock xblock) {
    var string js, Xob ls, SeqOfXob st, int i, ln, SeqOfOb lv;
	js = '';
    js * '{';
	ls = obsel(xblock~ob, Xblock_locals)~Xob;
	//lv = mget(ls,Regarding);
	/*if (nnul(ls)) {
		var SeqOfOb prps,int i,n, ob m;
		prps = obProperties(ls);
		n=length(prps);
		for(i=0;i<n;i++){
			writeln(prps[i]);
		}
	}*/
    if (nnul(ls)) {
		js * translateXob(ls);
	}
	st = obsel(xblock~ob, Xblock_statements)~SeqOfXob;
	ln = length(st);
	if (nnul(st) && (ln > 0)) {
		for (i = 0;i < ln;i++) {
			///js * i;
			//js * ' - ';
			js * translateXob(st[i]);
			//js * obsel(st[i], rdf:type);
		}
	}
    js * '}';
	return js;
}

string function funcname(Xapply xapply) {
	var string fns, ob fnn, Xob fn;
	fns = '';
	fn = obsel(xapply~ob, Xapply_functionOf)~Xob;
	fnn = obsel(fn, Function_name)~ob;
	fns * fnn;
	return fns;
}

string function translateEqual(Xapply xapply) {
    var string js, Xob dst, SeqOfXob dt, int ln,i;
	js = '';
	dst = obsel(xapply~ob, Xapply_dest)~Xob;
	if (nnul(dst)) {
		js * translateXob(dst);
		js * ' = ';
	}
	dt = obsel(xapply~ob, Xapply_arguments)~SeqOfXob;
	ln = length(dt);
	if (nnul(dt) && (ln == 2)) {
		js * translateXob(dt[0]);
		js * '===';
		js * translateXob(dt[1]);
	}
    return js;
}

string function translateMkStringBuf(Xapply xapply) {
    var string js, Xob dst, SeqOfXob dt, int ln,i;
	js = '';
	dt = obsel(xapply~ob, Xapply_arguments)~SeqOfXob;
	ln = length(dt);
	if (nnul(dt) && (ln == 1)) {
		js * "'";
		js * translateXob(dt[0]);
		js * "'";
	}
    return js;
}

string function translateApply(Xapply xapply) {
    var string js, fnn, Xob dst, SeqOfXob dt, int ln,i;
	js = '';
	fnn = funcname(xapply);
	if (fnn == 'equal') return translateEqual(xapply);
	if (fnn == 'mkStringBuf') return translateMkStringBuf(xapply);
	dst = obsel(xapply~ob, Xapply_dest)~Xob;
	if (nnul(dst)) {
		js * translateXob(dst);
		js * ' = ';
	}
	js * fnn; // TODO: decorate function name
	js * '(';
	dt = obsel(xapply~ob, Xapply_arguments)~SeqOfXob;
	ln = length(dt);
	if (nnul(dt) && (ln > 0)) {
		for (i = 0;i < (ln-1);i++) {
			js * translateXob(dt[i]);
			js * ',';
		}
		js * translateXob(dt[ln-1]);
	}
	js * ')';
    return js;
}

string function translateIf(Xif xif) {
    var string js, Xob iff;
	js = '';
    js * 'if(';
    js * translateXob(obsel(xif~ob, Xif_condition)~Xob);
    js * ') ';
    js * translateXob(obsel(xif~ob, Xif_ifTrue)~Xob);
    iff = obsel(xif~ob, Xif_ifFalse)~Xob;
	if (nnul(iff)) {
        js * ' else ';
        js * translateXob(iff);
    }
    return js;
}

string function translateXob(Xob x) {
    var string js;

	// writeln('type:',obsel(x, rdf:type),'  val  ',x);

	if (isConstant(x)) js = translateConstant(x);
	else if (isFunction(x~ob)) js = translateFunction(x~Function);
	else if (isBinding(x~ob)) js = translateBinding(x~Binding);
    else if (hasType(x~ob, Xassign)) js = translateAssign(x~Xassign);
	else if (hasType(x~ob, Xblock)) js = translateBlock(x~Xblock);
	else if (hasType(x~ob, Xapply)) js = translateApply(x~Xapply);
	else if (hasType(x~ob, Xif)) js = translateIf(x~Xif);
	else {
		js = '<unknown Xob type>: ';
		js * type0(x);
		js * ' ';
		//js * type1(x);
	}

	/*js * obkind(x);

	if (isObject(x)) {
		js * obsel(x, rdf:type);
	}*/

	return js;
}

string function translateToJS(Xob x) {
    var string js;

	if (nul(jsg)) {return '';}
	if (hasType(x~ob, Xapply) && (funcname(x~Xapply) == 'translateToJS')) { // exclude the call to translateJS itself from translation
		return '';
	}

	js = translateXob(x);

	jsg * js;

	return js;
}

outputTypesToJS = false;

/**
* Translation of global and local variable declarations.
*/
string function translateToJS(ob x,id nm,ob vl,Sort s) {
	var string js;

	js = 'var ';
	if (nnul(s) && outputTypesToJS) {
		js * '/*';
		js * s;
		js * '*/ ';
	}
	js * nm;
	if (nnul(vl)) {
		js * '=';
		js * vl;
	}
	js * ';';

	jsg * js;

	return js;
}

translateJS = false;

string function translateToJS(string fln) {
	var string fnc, Xob x, ob tp, SeqOfOb hp, int i, n;
	writeln('Translating ', fln);
	translateJS = true;
    load(fln); // this will parse and analyze the code and generate JS code
	translateJS = false;

	/*hp = homePath();
	n = length(hp);
	for (i=0;i<n;i++) {
		writeln(type0(hp[i]));
		translateXob(hp[i]~Xob);
	}*/

	return jsg;

	//write('r: ', thisFileR);
	//tp = fget(thisFileR,topicP);
	///jsg = translateToJS(lastXob);

	/*fnc = '';
	readFromFile(fnc, fln);
	x = evaluate(fnc)~Xob;
	return translateToJS(x);*/
}

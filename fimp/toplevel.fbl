/*
* Copyright (C) 2004 Map Bureau - http://www.mapbureau.com
*
* This package is Free Software released under the BSD license.
*
* See license.html at the top of this package for the full license terms.
*
*/

// Most code comments temporarily excised, pending review

var Sort lastParsedType;
var printResult = false; //turned back on in init.fbl, but not cgi.fbl


void function echoInput()
{
  var int ln;
  // various sanity checks
  if (!scanning_console) 
    {
	ln = length(scan_inbuf);
	if ((echoBegin < ln) && (c_scan_p < ln))
	  writeln(slice(scan_inbuf,echoBegin,c_scan_p));
	echoBegin = c_scan_p;
	}
}

Sort function _type(Binding b)
{
return obsel(b~ob,Binding_type)~Sort;
}

Sort function toFunctionType(Sort rtp,ob params)
  {
  var SeqOfBinding gds,int ln,i,SeqOfType itps,
      Binding cb;
  gds = bindings(params);
  ln = length(gds);
  itps = emptysequence(Sort);
  for (i =0;i<ln;i++)
      {
	  cb = gds[i];
	  if (nnul(cb)) push(itps,_type(cb));
	  }
  return mkFunctionType(rtp,itps);
  }

var enableAsm = true;

var disasmFunctions = false;

// add parameters to the asm data structures

void function addParameters(ob m)
  {
  var SeqOfBinding gd,int ln,i,Binding b;
  gd = bindings(m);
  ln = length(gd);
  for (i = 0;i<ln;i++)
      {
	  b = gd[i];
	  if (nnul(b)) addParameter(b);
	  }
   }


var Xob lastXob,lastFlatXob;

var xobHistory = emptysequence(Xob);
var flatXobHistory = emptysequence(Xob);
var collecting_xobHistory = false;
var analyzeFunctionVerbose = false;
collecting_xobHistory = false;//notneeded
analyzeFunctionVerbose = false;//notneeded
var c_params = nil;



var ob lastFunParse;
var Xob lastFX;
var Xob lastFF;


void function analyzeFunction(Sort rts,ob x)//new
  {
  var id fnm,pr,Xob bd,bdf,Sort fnsort,Pcode pcd,Function fn,Xblock bdbl,boolean ismeth,
      ob fnmo,ns,boolean cls;
  cls = collectingSubjects();
  // no need to collect the objects generated by the analyzer during its work
  set_collectingSubjects(false);
  lastFunParse = x;
  funReturnType = rts;
  analysisTempCount = 0;
  fnmo = cadr(x);
  if (obkind(fnmo)==string_kind) 
     {
	 fnm = fnmo ~ id;
	 ns = home;
     if (printResult) 
	    {
		if (echoMode && !scanning_console) echoInput();
		writeln(lf,'******FUNCTION******* ',fnm,lf);
		}
	 }
  else 
     {
	 if (isQname(fnmo))
	     {
		 pr = cadr(fnmo)~id;
		 fnm = caddr(fnmo) ~ id;
		 ns = namespace(pr);
		 }
	 else error('Function name must be an id or qualified name');
//	 qnm = toIQname(fnmo);
//	 fnm = localPart(qnm);
//    if (printResult) writeln('function: ',qnm);
	 }
  copyInto(cPath,homePath());
//  reset(cPath);
//  cPath+gev;
  c_params = mkResource();

  analyzeLocalVars(c_params~ob,caddr(x));
  push(cPath,c_params~ob);
  analyzingFunction = true;//only makes a difference when building fimp
  bd = analyze(cadddr(x));
  analyzingFunction = false;
  if (not(hasType(bd~ob,Xblock))) error('internal');
  bdbl =bd~Xblock;

   bitset(bdbl~ob,Xblock_booles,Xblock_isFunctionBody,1);
   obset(bdbl~ob,Xblock_returnType,funReturnType~ob);

//  bdbl . is_function_body = true;
//  bdbl . return_sort = funReturnType;
//  set_type(bd~Xob1,funReturnType);
  obset(bd~ob,Xob1_type,funReturnType~ob);

  if (collecting_xobHistory) push(xobHistory,bd);
  lastXob = bd;
  if (analyzeFunctionVerbose) writeln('Xob: ',bd);
  bdf = flatten_top(bd);
  if (analyzeFunctionVerbose) writeln('Flat Xob: ',bdf);
  lastFlatXob = bdf;
  lastFX = bd;
  lastFF = bdf;
  if (collecting_xobHistory) push(flatXobHistory,bdf);
  fnsort = toFunctionType(funReturnType,c_params);
  if (enableAsm)
     {
	 asmReset();
	 addParameters(c_params);
	 assemble(bdf);
	 asmWrapup();
	 if (disasmFunctions) 
	    {writeln('Disassembly of ',fnm);
		disasm(asmBuf,asmDblock);
		writeln('**end disassembly**');
		writeln();
		}
    pcd = iNew(Pcode)~Pcode;
	obset(pcd~ob,Pcode_code,copy(asmBuf)~ob);
	obset(pcd~ob,Pcode_dblock,asmDblock~ob);
//    pcd = new(Pcode);
//	pcd . code = copy(asmBuf);
//	pcd . dblock = asmDblock;
//	pcd . dblock_pool = emptysequence(Dblock);
// we do want to collect the function itself
    set_collectingSubjects(cls);
    fn = internFunction(ns,fnm,fnsort,pcd ~ ob);
	setFunctionOf(asmDblock,fn);

	}
 thisXob = nil ~ Xob;
}

/*

int function furb(int n){return n * n}

void function ww(SeqOfXob x)
{
  var int ln,i;
  ln = length(x);
  for (i=0;i<ln;i++) writeln(x[i]);
}


*/

var enableEval = false;
var analyzeTopVerbose = false;
var disasmTop = false;


ob function evaluate(Xob x)
  {
  var boolean cls;
     cls = collectingSubjects();
     set_collectingSubjects(false);
	 asmReset();
	 assemble(x);
	 asmWrapup();
	 if (disasmTop) disasm(asmBuf,asmDblock);
	 set_collectingSubjects(cls);
	 return pmEvaluate(asmDblock,copy(asmBuf));
     
   }

var printXob = false;

ob function evaluate_(ob xa)
  {
  var Xob bd,bdf,Sort rsrt,ob rs,ob x,boolean cls;
  cls = collectingSubjects();
  set_collectingSubjects(false);
  bd = analyzeToplevel(xa);
  if (printXob) writeln('Xob: ',bd);
  rsrt = type(bd);
  funReturnType = rsrt;
  lastXob = bd;
  bdf = flatten_top(bd);
  lastFlatXob = bdf;
  if (analyzeTopVerbose)  writeln('Non function ',bdf);
  if (enableAsm) 
    {
	set_collectingSubjects(cls);
	rs =evaluate(bdf);
	lastXob = bd;    // reset because evaluation may induce recursive calls to evaluate
	lastFlatXob = bdf;
	return rs;
	}
 set_collectingSubjects(cls);
 }

ob function evaluate(string s)
{
  return evaluate_(parse1(s));
}



ob function evaluateAndPrint(ob xa)
  {
  var ob rs; 
  if (printResult) 
     {
	 if (echoMode && !scanning_console)  echoInput();
     rs = evaluate_(xa);
	 if (echoMode && !scanning_console) write("-->");
	 uwriteln(rs,type(lastXob));
	 }
  else rs = evaluate_(xa);
  return rs;
  }




void function analyzeTopVars(ob x,boolean isConstant)
  {
  var ob cx,ce,Sort lsts,srt,ob vl,nmo,id nm,ob bnd;
  copyInto(cPath,homePath());
  cx = x;
  lsts = nil ~ Sort;
  while (isList(cx))
        {
		ce = car(cx);
		if (obkind(ce)==string_kind)
		   {
		   if (nul(lsts)) error('Class needed for variable ',ce);
		   if (nul(classBeingDefined)) 
		      {
			  if (isConstant) error('A value needs to be supplied for the constant ',ce~id);
			  else bindGlobal(home,ce~id,lsts); 
			  }


           // LATER add correct constant handling here
		   else addField(classBeingDefined,ce~id,lsts);
		   } 
		else

        if (isList(ce))
           {
	       if (eq(car(ce),'assign'))
	          {
		      vl = evaluate_(caddr(ce) ~ ob);
			  nmo = cadr(ce);

			     {
			     nm = cadr(ce)~id;
			     srt = type(lastXob);
		         if (nul(classBeingDefined))  
				    {
					if (isConstant) bindConstant(home,nm,vl,srt);
					else bindGlobal(home,nm,vl,srt);
					}

			     else			  
			     error('Cannot assign default values in a sort definition yet');
				 }
			  }
		   else 
		      {
			  lsts =  analyzeTypedVar(home,ce,false);
			  }
		   }
		cx = cdr(cx);
		}
   if (echoMode && !scanning_console) echoInput();
    }





var lastValue = nil;
var lastParse = nil;

void function analyzeTop(ob ce) //new
  {
  var boolean prce;
  lastParse = ce;
  prce = isList(ce);
  if (prce)
	 {
	 if  (eq(car(ce),'function'))  
		 analyzeFunction(analyzeTypen(cadr(ce)),cons('function'~ob,cdr(cdr(ce)))); 
	 else
	 if (eq(car(ce),'var')) analyzeTopVars(cdr(ce),false); else
	 if (eq(car(ce),'constant')) analyzeTopVars(cdr(ce),true); else
		 {
		 lastValue = evaluateAndPrint(ce~ob);
		 lastParsedType = void;
		 }
	}
  else
    {
	 lastValue = evaluateAndPrint(ce~ob);
	lastParsedType = void;
	}
  }



//var um_is_done = false;
var fablDoneId  = 'exit';
var fablEval = true;
var ob lastFablParse;
var printParseResults = false;
printParseResults = false;
var fablLoopDepth = 0;
var fablLoopPop = false;

void function fablLoop(boolean cn)
  {
  var ob cv,dtv,boolean um_is_done,cls;
  um_is_done = false;
  fablLoopDepth++;
  while (not(um_is_done)) 
     {
	 scanning_console = cn;
     cls = collectingSubjects();
	 set_collectingSubjects(false);
	 cv =parseToplevel();
	 set_collectingSubjects(cls);
	 if (parse_verbose) writeln('Parse toplevel = ',cv);
	 if (eq(cv,eof_parse)) um_is_done = true; else
	    {
	    set_collectingSubjects(false);
		dtv =  detokenify(cv);
	    set_collectingSubjects(cls);
		if (eq(dtv,fablDoneId)) 
		   {
		   um_is_done = true; 
		   writeln('EXIT break');
		   }
		else
		{
        lastFablParse = dtv;
	     if (printParseResults) writeln(dtv);
         if (fablEval) analyzeTop(dtv);
		 }
		}
	 if (fablLoopPop)
	    {
		fablLoopPop = false;
		um_is_done = true;
		}
	 }
		fablLoopDepth--;
 }

void function fablConsole()
  {
  writeln('fablConsole 2');
  scanning_console = true;
  scan_reset();
  flushConsole();
  fablLoop(true);
  }





// called from C to install new C functions (install_c_function)


Function function installFunction(ob cn,id fnm,SeqOfId itps)
  {
  var SeqOfType srts,int ln,i,Function fn,Sort rt;
  srts = emptysequence(Sort);
  ln = length(itps);
 rt = analyzeTypen(itps[0] ~ob);
  for (i = 1;i<ln;i++)
      push(srts , analyzeTypen(itps[i]~ob));
  fn = internFunction(cn,fnm,mkFunctionType(rt,srts));
  return fn;
  }



